
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>DJ × VJ (WebSocket Communication)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" href="./style.css">
  </head>
  <body>
    <div id="topbar">
      <div id="role" class="badge">role: …</div>
      <div id="status">ws: waiting for assign…</div>
    </div>
    <button id="startAudio" style="display:none">Enable Audio</button>
    <div id="app"></div>
    
    <!-- VJ p5js : https://editor.p5js.org/feliciatiffany/sketches/4HmfQk1Fj -->
    <!-- DJ p5js : https://editor.p5js.org/feliciatiffany/sketches/9vIniii-M -->
    <script>
      // let ws = new WebSocket('ws://localhost:3000');
      let ws = new WebSocket('wss://collaborative-djvj.onrender.com');

      const roleEl = document.getElementById('role');
      const statusEl = document.getElementById('status');
      const startAudioBtn = document.getElementById('startAudio');
      let role = null;
      let ghostShapes = null;
      let loopSound;
      let reverbFX, delayFX, resonanceFX;
      let tri, cir, star, plus;
      const margin = 80;
      let draggedShape = null; // FIX: declare to avoid implicit global

      //  unique ID for each player
      let myId = Math.random().toString(36).slice(2); 

      // for debugging, check if open, error, or close. First connection check
      ws.onopen = () => {
        console.log('WebSocket connection established');
        ws.send(JSON.stringify({ type: 'join', id: myId })); // Send the player ID to join
      };

      ws.onerror = (event) => {
        console.error('WebSocket error:', event);
      };

      ws.onclose = (event) => {
        console.log('WebSocket connection closed:', event);
      };

      // WebSocket message handler
      ws.onmessage = (event) => {
        console.log('Received message:', event.data);
        try {
          const msg = JSON.parse(event.data);

          // help with role assignment 
          if (msg.type === 'assign' && !role) {
            // Assign the role (DJ or VJ)
            role = msg.role;
            // displayed on interface
            roleEl.textContent = 'role: ' + role;
            statusEl.textContent = 'ws: connected';

            // Initialize shapes and audio based on role
            if (role === 'dj') {
              startAudioBtn.style.display = 'inline-block';
              // don't know why the loadDJ sound always have problem
              // loadDJSound();
              // loopSound.setVolume(0); // FIX: don't touch before loaded
              // Initialize audio effects, will be changed later
              // reverbFX = new p5.Reverb(); // will create FX after sound exists
              // delayFX = new p5.Delay();
              // resonanceFX = new p5.LowPass();
              // Apply effects on the sound
              // resonanceFX.process(loopSound);
              // delayFX.process(loopSound, 0, 0, 1500);
              // reverbFX.process(loopSound, 0, 0);
              // reverbFX.drywet(0);
              setupShapes();
            } else if (role === 'vj') {
              setupShapes();
            }
          }

          // Ghost shape data handle : receiving and have position updates from the other player
          if (msg.type === 'state' && msg.role !== role) {
            ghostShapes = msg.shapes || null;
            console.log('Received state from other player:', ghostShapes);
          }
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
        }
      };

      // p5.js setup function
      function setup() {
        createCanvas(windowWidth, windowHeight); 
        textAlign(CENTER);
        textSize(16);
        setupShapes();  
      }

      // Function to initialize shapes (same for both DJ and VJ)
      function setupShapes() {
        tri = { x: width * 0.25, y: height * 0.6, size: 50, col: color('#F0A533'), type:'triangle' };
        cir = { x: width * 0.75, y: height * 0.3, r: 45, col: color('#0B4B8B'), type:'circle' };
        star = { x: width * 0.25, y: height * 0.25, rOuter: 45, rInner: 20, col: color('#FCF5AF'), type:'star' };
        plus = { x: width * 0.75, y: height * 0.65, size: 50, col: color('#F44F0A'), type:'plus' };
      }

      function draw() {
        background(30);

        // Draw shapes. go to function for each shape
        drawTriangleShape(tri);
        drawCircleShape(cir);
        drawStarShape(star);
        drawPlusShape(plus);

        // Handle ghost shapes from the other player
        if (ghostShapes) drawGhost(ghostShapes);

        // If role is DJ, handle audio control and draw the DJ bar
        if (role === 'dj') {
          //  && loopSound
          // console.log("DJ role active");
          if (!loopSound || !loopSound.isPlaying()) { // FIX: guard when loopSound is undefined / not loaded
            startAudioBtn.style.display = 'inline-block';
          }
          console.log ("draw radial wave from DJ");
          // also draw from VJ
          drawRadialWaveCrazy(); 

          // Update audio from shape positions
          updateAudioFromShapes();  
          drawDJBar();  
        }

        // If role is VJ, draw visual wave and the VJ bar
        if (role === 'vj') {
          drawRadialWaveCrazy();  
          
          // also update audtio from DJ shapes
          // updateAudioFromShapes();  

          drawVJBar(); 
        }
      }

      // Function to load sound for DJ role
      function loadDJSound() {
        // FIX: load only after userStartAudio(); set up FX and start loop on success
        loopSound = loadSound('assets/djlexCUT.mp3', () => {
          console.log("Sound file loaded successfully.");
          // Initialize audio effects, will be changed later
          if (!reverbFX) reverbFX = new p5.Reverb();
          if (!delayFX) delayFX = new p5.Delay();
          if (!resonanceFX) resonanceFX = new p5.LowPass();

          // Apply effects on the sound (after it's created)
          resonanceFX.process(loopSound);
          delayFX.process(loopSound, 0, 0, 1500);
          reverbFX.process(loopSound, 2, 2);
          reverbFX.drywet(0);

          loopSound.setVolume(0);
          loopSound.loop(); // start playback now that it's unlocked + loaded
          startAudioBtn.style.display = 'none';
          startAudioBtn.disabled = false; // Enable button once the sound is loaded
        }, (error) => {
          console.error("Error loading sound file:", error); //always go here
          startAudioBtn.disabled = true;  // Disable button if error occurs
          alert('Failed to load assets/djlexCUT.mp3. Make sure the file exists and is served from the same origin.');
        });
      }

      // Function to play sound when clicked
      startAudioBtn.onclick = function () {
        // FIX: unlock audio context first (required by browsers)
        userStartAudio().then(() => {
          if (!loopSound) {
            // First click: load + start
            loadDJSound();
            return;
          }

          if (loopSound && loopSound.isLoaded()) {
            loopSound.loop();
            startAudioBtn.style.display = 'none';  // Hide button after playing sound
          } else {
            // always goes here
            console.error("Sound is not loaded yet!"); 
          }
        }).catch((e) => {
          console.error('Audio unlock failed:', e);
        });
      };

      // Function to draw the DJ bar : blue
      function drawDJBar() {
        noStroke();
        fill("#0A5598");
        rect(0, height - 120, width, 120);  // Bar across the bottom
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(30);
        text('Drag shapes to control your MUSIC', width / 2, height - 50);

        textSize(15);
        fill(220);
        text('Triangle/Volume   Circle/Reverb   Star/Delay   Plus/Resonance', width / 2, height - 90);
      }

      // Function to draw the VJ bar : red
      function drawVJBar() {
        noStroke();
        fill("#BA0113");
        rect(0, height - 120, width, 120);  // Bar across the bottom
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(30);
        text('Drag shapes to control your WAVE', width / 2, height - 50);

        textSize(15);
        fill(220);
        text('Triangle/Power   Circle/Softness   Star/Speed   Plus/Chaos', width / 2, height - 90);
      }

      //  triangle shape
      function drawTriangleShape(s) {
        fill(s.col);
        noStroke();
        const h = s.size;
        triangle(s.x - h, s.y + h, s.x + h, s.y + h, s.x, s.y - h);
      }

      // circle shape
      function drawCircleShape(s) {
        fill(s.col);
        noStroke();
        ellipse(s.x, s.y, s.r * 2, s.r * 2);
      }

      // star shape
      function drawStarShape(s) {
        push();
        translate(s.x, s.y);
        fill(s.col);
        noStroke();
        const npoints = 6;
        const angle = TWO_PI / npoints;
        const halfAngle = angle / 2.0;
        beginShape();
        for (let a = 0; a < TWO_PI; a += angle) {
          let sx = cos(a) * s.rOuter;
          let sy = sin(a) * s.rOuter;
          vertex(sx, sy);
          sx = cos(a + halfAngle) * s.rInner;
          sy = sin(a + halfAngle) * s.rInner;
          vertex(sx, sy);
        }
        endShape(CLOSE);
        pop();
      }

      // plus shape
      function drawPlusShape(s) {
        push();
        translate(s.x, s.y);
        fill(s.col);
        noStroke();
        const t = s.size / 3;
        const l = s.size;
        rect(-t / 2, -l, t, 2 * l);
        rect(-l, -t / 2, 2 * l, t);
        pop();
      }


      // Ghost shapes drawing (from other player)
      function drawGhost(shapes) {
        shapes.forEach(shape => {
          if (shape.type === 'triangle') drawTriangleShape(shape);
          else if (shape.type === 'circle') drawCircleShape(shape);
          else if (shape.type === 'star') drawStarShape(shape);
          else if (shape.type === 'plus') drawPlusShape(shape);
        });
      }

      // Update audio parameters for DJ based on shape positions
      function updateAudioFromShapes() {
        // FIX: guard when audio/FX not ready
        if (!loopSound || !loopSound.isLoaded() || !reverbFX || !delayFX || !resonanceFX) return;

        let volume = map(tri.y, height - margin, margin, 0, 4, true);
        let reverbWet = map(cir.y, margin, height - margin, 0, 1, true);
        let delayFb = map(star.x, margin, width - margin, 0, 1, true);
        let resonance = map(plus.x, margin, width - margin, 0.1, 20, true);

        loopSound.setVolume(volume);
        reverbFX.drywet(reverbWet);
        delayFX.feedback(delayFb);
        resonanceFX.res(resonance);
      }

      // Visual effect drawing for VJ (radial wave)
      function drawRadialWaveCrazy() {
        let p = map(tri.y, height - margin, margin, 0, 1, true); // power
        let s = map(cir.y, margin, height - margin, 0, 1, true); // softness
        let sp = map(star.x, margin, width - margin, 0, 1, true); // speed
        let ch = map(plus.x, margin, width - margin, 0, 1, true); // chaos

        let t = frameCount * (0.005 + sp * 0.25);
        let spacing = map(s, 0, 1, 26, 8);
        let dotSize = map(s, 0, 1, 2, 7);
        let rayCount = int(map(sp, 0, 1, 8, 80));
        let sharpness = map(p, 0, 1, 1.5, 12);
        let baseAmp = map(p, 0, 1, 0.8, 3.5);
        let radiusMax = sqrt(width * width + height * height) * map(p, 0, 1, 0.4, 0.8);
        let noiseScale = map(ch, 0, 1, 0.0, 0.02);
        let noiseStrength = map(ch, 0, 1, 0.0, 4.0);
        let bendAmount = map(ch, 0, 1, 0.0, 1.0);

        colorMode(HSB, 360, 100, 100, 100);
        noStroke();

        for (let y = 0; y < height - 120; y += spacing) {
          for (let x = 0; x < width; x += spacing) {
            let dx = x - width / 2;
            let dy = y - height / 2;
            let r = sqrt(dx * dx + dy * dy);
            let rNorm = r / radiusMax;
            let angle = atan2(dy, dx);
            if (bendAmount > 0) angle += bendAmount * sin(angle * 4.0 + t * 2.0);
            let angNorm = (angle + PI) / TWO_PI;
            let rayPhase = angle * rayCount + t * (1.0 + sp * 2.0);
            let base = max(0, cos(rayPhase) * baseAmp);
            let beam = pow(base, sharpness);
            let harmonic = max(0, cos(rayPhase * 3.0 - t * 3.0));
            beam += 0.35 * pow(harmonic, 4);

            if (noiseScale > 0.0) {
              let n = noise(x * noiseScale, y * noiseScale, t * 0.7);
              beam *= 1.0 + (n - 0.5) * noiseStrength;
            }

            let falloffExp = map(p, 0, 1, 1.4, 0.6);
            let radial = max(0, 1.0 - pow(rNorm, falloffExp));
            let intensity = constrain(beam * radial, 0, 1);
            if (intensity < 0.03) continue;

            let hue = (angNorm * 360 * 3.0 + t * 60.0) % 360;
            let sat = 70 + 30 * intensity;
            let bri = 20 + 80 * pow(intensity, 0.9);
            let alpha = (50 + 70 * intensity) * (0.2 + 0.8 * p);

            fill(hue, sat, bri, alpha);
            ellipse(x, y, dotSize, dotSize);
          }
        }

        colorMode(RGB, 255);
      }

      // Mouse interaction: drag controllers
      function mousePressed() {
        if (hitCircle(cir, mouseX, mouseY)) {
          draggedShape = cir;
        } else if (hitTriangle(tri, mouseX, mouseY)) {
          draggedShape = tri;
        } else if (hitStar(star, mouseX, mouseY)) {
          draggedShape = star;
        } else if (hitPlus(plus, mouseX, mouseY)) {
          draggedShape = plus;
        } else {
          draggedShape = null;
        }
      }

      function mouseDragged() {
        if (!draggedShape) return;

        draggedShape.x = constrain(mouseX, margin, width - margin);
        draggedShape.y = constrain(mouseY, margin, height - 180);
        
        // Send the shape position to the other player via WebSocket
        ws.send(JSON.stringify({
          type: 'state',
          role: role,
          shapes: [tri, cir, star, plus]
        }));
      }

      function mouseReleased() {
        draggedShape = null;
      }

      // Hit test for shapes
      function hitCircle(s, px, py) {
        return dist(px, py, s.x, s.y) <= s.r;
      }

      function hitTriangle(s, px, py) {
        let r = s.size * 1.1;
        return dist(px, py, s.x, s.y) <= r;
      }

      function hitStar(s, px, py) {
        let r = s.rOuter * 1.1;
        return dist(px, py, s.x, s.y) <= r;
      }

      function hitPlus(s, px, py) {
        const half = s.size;
        return px >= s.x - half && px <= s.x + half &&
               py >= s.y - half && py <= s.y + half;
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        [tri, cir, star, plus].forEach(s => {
          s.x = constrain(s.x, margin, width - margin);
          s.y = constrain(s.y, margin, height - margin);
        });
      }
    </script>
  </body>
</html>
