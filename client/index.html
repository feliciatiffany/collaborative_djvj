<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>DJ × VJ (WebSocket Communication)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: #000;
        color: #fff;
        font-family: system-ui, sans-serif;
      }
      #topbar {
        position: fixed;
        left: 0;
        right: 0;
        top: 0;
        height: 42px;
        display: flex;
        gap: 10px;
        align-items: center;
        padding: 0 12px;
        border-bottom: 1px solid #222;
        z-index: 10;
        background: #000;
      }
      #status {
        opacity: .8;
      }
      #role {
        padding: 2px 8px;
        background: #333;
        border-radius: 4px;
      }
      #startAudio {
        position: fixed;
        right: 12px;
        top: 50px;
        z-index: 20;
        padding: 8px 16px;
        border-radius: 8px;
        border: 1px solid #444;
        background: #0b4b8b;
        color: #fff;
        cursor: pointer;
        font-size: 14px;
      }
      #startAudio:hover {
        background: #0d5fb8;
      }
      #app {
        position: absolute;
        top: 42px;
        bottom: 0;
        left: 0;
        right: 0;
      }
    </style>
  </head>
  <body>
    <div id="topbar">
      <div id="role" class="badge">role: …</div>
      <div id="status">ws: waiting for assign…</div>
    </div>
    <button id="startAudio" style="display:none">Enable Audio</button>
    <div id="app"></div>
    
    <script>
      // WebSocket connection - change to your server URL
      let ws = new WebSocket('ws://localhost:3000');
      // For production: let ws = new WebSocket('wss://collaborative-djvj.onrender.com');

      const roleEl = document.getElementById('role');
      const statusEl = document.getElementById('status');
      const startAudioBtn = document.getElementById('startAudio');
      
      let role = null;
      let myShapes = { tri: null, cir: null, star: null, plus: null };
      let otherShapes = null; // Shapes from the other player
      
      let loopSound;
      let reverbFX, delayFX, resonanceFX;
      const margin = 80;
      let draggedShape = null;
      let myId = Math.random().toString(36).slice(2);

      // WebSocket handlers
      ws.onopen = () => {
        console.log('WebSocket connection established');
        ws.send(JSON.stringify({ type: 'join', id: myId }));
      };

      ws.onerror = (event) => {
        console.error('WebSocket error:', event);
        statusEl.textContent = 'ws: error';
      };

      ws.onclose = (event) => {
        console.log('WebSocket connection closed:', event);
        statusEl.textContent = 'ws: disconnected';
      };

          ws.onmessage = (event) => {
          try {
            const msg = JSON.parse(event.data);

            // Role assignment
            if (msg.type === 'assign' && !role) {
              role = msg.role;
              roleEl.textContent = 'role: ' + role;
              statusEl.textContent = 'ws: connected';

              if (role === 'dj') {

                startAudioBtn.style.display = 'inline-block'; // Show button for DJ role
              }
            }

            // Receive state updates from the other player
            if (msg.type === 'state' && msg.role !== role) {
              otherShapes = msg.shapes;
            }
            if (msg.type === 'vjsound' && msg.role !== role) {
             
                loadDJSound(); 
            }


            // console.log(otherShapes);

          // }
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
        }
      };

      // p5.js setup
      function setup() {
        createCanvas(windowWidth, windowHeight); 
        textAlign(CENTER);
        textSize(16);
        
        // Initialize my shapes
        myShapes.tri = { x: width * 0.25, y: height * 0.6, size: 50, col: color('#F0A533'), type:'triangle' };
        myShapes.cir = { x: width * 0.75, y: height * 0.3, r: 45, col: color('#0B4B8B'), type:'circle' };
        myShapes.star = { x: width * 0.25, y: height * 0.25, rOuter: 45, rInner: 20, col: color('#FCF5AF'), type:'star' };
        myShapes.plus = { x: width * 0.75, y: height * 0.65, size: 50, col: color('#F44F0A'), type:'plus' };

        otherShapes = myShapes;
      }

      function draw() {
        background(30);

        // Draw my shapes (bright)
        push();
        noStroke();
        drawTriangleShape(myShapes.tri);
        drawCircleShape(myShapes.cir);
        drawStarShape(myShapes.star);
        drawPlusShape(myShapes.plus);
        pop();

        

        // Role-specific rendering and control
        if (role === 'dj') {
          // DJ controls audio with their own shapes
          updateAudioFromShapes(myShapes);
            // console.log("Other Shapes in DJ:", otherShapes);


          // drawRadialWaveFromShapes(otherShapes);
          // console.log('My new shapes:', [myShapes.tri, myShapes.cir, myShapes.star, myShapes.plus]);
          // // DJ sees visuals controlled by VJ's shapes
          if (otherShapes && Array.isArray(otherShapes)) {
            
            drawRadialWaveFromShapes(otherShapes);
          }

          drawRadialWaveFromShapes(myShapes);



          // else {
          //   // Default visual if VJ hasn't moved yet
          //   drawRadialWaveFromShapes([myShapes.tri, myShapes.cir, myShapes.star, myShapes.plus]);
          // }
          
          drawDJBar();
        } if (role === 'vj') {
            drawRadialWaveFromShapes([myShapes.tri, myShapes.cir, myShapes.star, myShapes.plus]);

            // console.log("Other Shapes in VJ:", otherShapes);


            
              updateAudioFromShapes(otherShapes);  // Update the sound based on the shapes
            


            drawVJBar();
          }

      }

      // Audio loading
      function loadDJSound() {
        if (!loopSound) { // Ensure the sound is loaded only once
          loopSound = loadSound('assets/djlexCUT.mp3', () => {
            console.log("Sound file loaded successfully.");

            if (!reverbFX) reverbFX = new p5.Reverb();
            if (!delayFX) delayFX = new p5.Delay();
            if (!resonanceFX) resonanceFX = new p5.LowPass();

            resonanceFX.process(loopSound);
            delayFX.process(loopSound, 0, 0, 1500);
            reverbFX.process(loopSound, 2, 2);
            reverbFX.drywet(0);

            loopSound.setVolume(1);
            loopSound.loop();
            startAudioBtn.style.display = 'none'; // Hide button after loading sound
          }, (error) => {
            console.error("Error loading sound file:", error);
            startAudioBtn.textContent = 'Audio Load Failed';
            startAudioBtn.disabled = true;
          });
        }
      }


      startAudioBtn.onclick = function () {
        userStartAudio().then(() => {
          if (!loopSound || !loopSound.isLoaded()) {
            loadDJSound();
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({
                type: 'vjsound',
              }));
            }
          } else {
            loopSound.loop();
            startAudioBtn.style.display = 'none';
          }
        }).catch((e) => {
          console.error('Audio unlock failed:', e);
        });
      };
      

      // Update audio based on shape positions
      function updateAudioFromShapes(shapes) {
        if (!loopSound || !loopSound.isLoaded() || !reverbFX || !delayFX || !resonanceFX) return;

        const tri = shapes.tri || shapes[0];
        const cir = shapes.cir || shapes[1];
        const star = shapes.star || shapes[2];
        const plus = shapes.plus || shapes[3];

        if (!tri || !cir || !star || !plus) return;

        let volume = map(tri.y, height - margin, margin, 0, 4, true);
        let reverbWet = map(cir.y, margin, height - margin, 0, 1, true);
        let delayFb = map(star.x, margin, width - margin, 0, 1, true);
        let resonance = map(plus.x, margin, width - margin, 0.1, 20, true);

        loopSound.setVolume(volume);
        reverbFX.drywet(reverbWet);
        delayFX.feedback(delayFb);
        resonanceFX.res(resonance);
      }

      // Visual wave rendering
      function drawRadialWaveFromShapes(shapes) {

        
        const tri = shapes[0] || shapes.tri || { y: height * 0.6 };
        const cir = shapes[1] || shapes.cir || { y: height * 0.3 };
        const star = shapes[2] || shapes.star || { x: width * 0.25 };
        const plus = shapes[3] || shapes.plus || { x: width * 0.75 };

        // const tri = shapes[0] || shapes.tri;
        // const cir = shapes[1] || shapes.cir ;
        // const star = shapes[2] || shapes.star;
        // const plus = shapes[3] || shapes.plus ;
        let p = map(tri.y, height - margin, margin, 0, 1, true);
        let s = map(cir.y, margin, height - margin, 0, 1, true);
        let sp = map(star.x, margin, width - margin, 0, 1, true);
        let ch = map(plus.x, margin, width - margin, 0, 1, true);

        let t = frameCount * (0.005 + sp * 0.25);
        let spacing = map(s, 0, 1, 26, 8);
        let dotSize = map(s, 0, 1, 2, 7);
        let rayCount = int(map(sp, 0, 1, 8, 80));
        let sharpness = map(p, 0, 1, 1.5, 12);
        let baseAmp = map(p, 0, 1, 0.8, 3.5);
        let radiusMax = sqrt(width * width + height * height) * map(p, 0, 1, 0.4, 0.8);
        let noiseScale = map(ch, 0, 1, 0.0, 0.02);
        let noiseStrength = map(ch, 0, 1, 0.0, 4.0);
        let bendAmount = map(ch, 0, 1, 0.0, 1.0);

        colorMode(HSB, 360, 100, 100, 100);
        noStroke();

        for (let y = 0; y < height - 120; y += spacing) {
          for (let x = 0; x < width; x += spacing) {
            let dx = x - width / 2;
            let dy = y - height / 2;
            let r = sqrt(dx * dx + dy * dy);
            let rNorm = r / radiusMax;
            let angle = atan2(dy, dx);
            if (bendAmount > 0) angle += bendAmount * sin(angle * 4.0 + t * 2.0);
            let angNorm = (angle + PI) / TWO_PI;
            let rayPhase = angle * rayCount + t * (1.0 + sp * 2.0);
            let base = max(0, cos(rayPhase) * baseAmp);
            let beam = pow(base, sharpness);
            let harmonic = max(0, cos(rayPhase * 3.0 - t * 3.0));
            beam += 0.35 * pow(harmonic, 4);

            if (noiseScale > 0.0) {
              let n = noise(x * noiseScale, y * noiseScale, t * 0.7);
              beam *= 1.0 + (n - 0.5) * noiseStrength;
            }

            let falloffExp = map(p, 0, 1, 1.4, 0.6);
            let radial = max(0, 1.0 - pow(rNorm, falloffExp));
            let intensity = constrain(beam * radial, 0, 1);
            if (intensity < 0.03) continue;

            let hue = (angNorm * 360 * 3.0 + t * 60.0) % 360;
            let sat = 70 + 30 * intensity;
            let bri = 20 + 80 * pow(intensity, 0.9);
            let alpha = (50 + 70 * intensity) * (0.2 + 0.8 * p);

            fill(hue, sat, bri, alpha);
            ellipse(x, y, dotSize, dotSize);
          }
        }

        colorMode(RGB, 255);
      }

      // UI bars
      function drawDJBar() {
        noStroke();
        fill("#0A5598");
        rect(0, height - 120, width, 120);
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(30);
        text('Drag shapes to control your MUSIC', width / 2, height - 50);
        textSize(15);
        fill(220);
        text('Triangle/Volume   Circle/Reverb   Star/Delay   Plus/Resonance', width / 2, height - 90);
      }

      function drawVJBar() {
        noStroke();
        fill("#BA0113");
        rect(0, height - 120, width, 120);
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(30);
        text('Drag shapes to control your WAVE', width / 2, height - 50);
        textSize(15);
        fill(220);
        text('Triangle/Power   Circle/Softness   Star/Speed   Plus/Chaos', width / 2, height - 90);
      }

      // Shape drawing functions
      function drawTriangleShape(s) {
        fill(s.col);
        const h = s.size;
        triangle(s.x - h, s.y + h, s.x + h, s.y + h, s.x, s.y - h);
      }

      function drawCircleShape(s) {
        fill(s.col);
        ellipse(s.x, s.y, s.r * 2, s.r * 2);
      }

      function drawStarShape(s) {
        push();
        translate(s.x, s.y);
        fill(s.col);
        const npoints = 6;
        const angle = TWO_PI / npoints;
        const halfAngle = angle / 2.0;
        beginShape();
        for (let a = 0; a < TWO_PI; a += angle) {
          let sx = cos(a) * s.rOuter;
          let sy = sin(a) * s.rOuter;
          vertex(sx, sy);
          sx = cos(a + halfAngle) * s.rInner;
          sy = sin(a + halfAngle) * s.rInner;
          vertex(sx, sy);
        }
        endShape(CLOSE);
        pop();
      }

      function drawPlusShape(s) {
        push();
        translate(s.x, s.y);
        fill(s.col);
        const t = s.size / 3;
        const l = s.size;
        rect(-t / 2, -l, t, 2 * l);
        rect(-l, -t / 2, 2 * l, t);
        pop();
      }

      // Mouse interaction
      function mousePressed() {
        if (hitCircle(myShapes.cir, mouseX, mouseY)) {
          draggedShape = myShapes.cir;
        } else if (hitTriangle(myShapes.tri, mouseX, mouseY)) {
          draggedShape = myShapes.tri;
        } else if (hitStar(myShapes.star, mouseX, mouseY)) {
          draggedShape = myShapes.star;
        } else if (hitPlus(myShapes.plus, mouseX, mouseY)) {
          draggedShape = myShapes.plus;
        } else {
          draggedShape = null;
        }
      }

      function mouseDragged() {
        if (!draggedShape) return;

        draggedShape.x = constrain(mouseX, margin, width - margin);
        draggedShape.y = constrain(mouseY, margin, height - 180);

        // Send updated positions to the other player
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'state',
            role: role,
            shapes: [myShapes.tri, myShapes.cir, myShapes.star, myShapes.plus],
          }));
        }
      }

      function mouseReleased() {
        draggedShape = null;
      }

      // Hit detection
      function hitCircle(s, px, py) {
        return dist(px, py, s.x, s.y) <= s.r;
      }

      function hitTriangle(s, px, py) {
        let r = s.size * 1.1;
        return dist(px, py, s.x, s.y) <= r;
      }

      function hitStar(s, px, py) {
        let r = s.rOuter * 1.1;
        return dist(px, py, s.x, s.y) <= r;
      }

      function hitPlus(s, px, py) {
        const half = s.size;
        return px >= s.x - half && px <= s.x + half &&
               py >= s.y - half && py <= s.y + half;
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        Object.values(myShapes).forEach(s => {
          if (s) {
            s.x = constrain(s.x, margin, width - margin);
            s.y = constrain(s.y, margin, height - margin);
          }
        });
      }
    </script>
  </body>
</html>