<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>DJ × VJ (WebSocket Communication)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/addons/p5.sound.min.js"></script>
    <link rel="stylesheet" href="./style.css">
  </head>
  <body>
    <div id="topbar">
      <div id="role" class="badge">role: …</div>
      <div id="status">ws: waiting for assign…</div>
    </div>
    <button id="startAudio" style="display:none">Enable Audio</button>
    <div id="app"></div>
    
     <!-- VJ p5js : https://editor.p5js.org/feliciatiffany/sketches/4HmfQk1Fj -->
    <!-- DJ p5js : https://editor.p5js.org/feliciatiffany/sketches/9vIniii-M -->
    <script>
      let ws = new WebSocket('ws://localhost:3000');
      const roleEl = document.getElementById('role');
      const statusEl = document.getElementById('status');
      const startAudioBtn = document.getElementById('startAudio');
      let role = null;
      let ghostShapes = null;
      let loopSound;
      let reverbFX, delayFX, resonanceFX;
      let tri, cir, star, plus;
      const margin = 80;
      let draggedShape = null;

      // Unique ID for each player
      let myId = Math.random().toString(36).slice(2); 

      // for debugging, check if open, error, or close. First connection check
      ws.onopen = () => {
        console.log('WebSocket connection established');
        ws.send(JSON.stringify({ type: 'join', id: myId })); // Send the player ID to join
      };

      ws.onerror = (event) => {
        console.error('WebSocket error:', event);
      };

      ws.onclose = (event) => {
        console.log('WebSocket connection closed:', event);
      };

     // WebSocket message handler
      ws.onmessage = (event) => {
        console.log('Received message:', event.data);
        try {
          const msg = JSON.parse(event.data);

          // Assign role (DJ or VJ)
          if (msg.type === 'assign' && !role) {
            role = msg.role;
            roleEl.textContent = 'role: ' + role;
            statusEl.textContent = 'ws: connected';

            loadDJSound(); 
            setupShapes();
            if (role === 'dj') {
              startAudioBtn.style.display = 'inline-block';
             
            } 
             // don't know why the loadDJ sound always have problem
              // loadDJSound();
              // loopSound.setVolume(0); 
              // Initialize audio effects, will be changed later
              // reverbFX = new p5.Reverb(); // will create FX after sound exists
              // delayFX = new p5.Delay();
              // resonanceFX = new p5.LowPass();
              // Apply effects on the sound
              // resonanceFX.process(loopSound);
              // delayFX.process(loopSound, 0, 0, 1500);
              // reverbFX.process(loopSound, 0, 0);
              // reverbFX.drywet(0);
          }

          // Handle state updates from the other player
          if (msg.type === 'state' && msg.role !== role) {
            ghostShapes = msg.shapes || null;
            if (role === 'vj') {
              // VJ: Update visual based on DJ shapes
              updateVisualFromShapes(ghostShapes);
            } else if (role === 'dj') {
              // DJ: Update sound based on VJ shapes
              updateSoundFromShapes(ghostShapes);
            }
          }
        } catch (error) {
          console.error('Error processing WebSocket message:', error);
        }
      };

      // Initialize canvas and shapes
      function setup() {
        createCanvas(windowWidth, windowHeight); 
        textAlign(CENTER);
        textSize(16);
        setupShapes();  
      }

      function setupShapes() {
        tri = { x: width * 0.25, y: height * 0.6, size: 50, col: color('#F0A533'), type:'triangle' };
        cir = { x: width * 0.75, y: height * 0.3, r: 45, col: color('#0B4B8B'), type:'circle' };
        star = { x: width * 0.25, y: height * 0.25, rOuter: 45, rInner: 20, col: color('#FCF5AF'), type:'star' };
        plus = { x: width * 0.75, y: height * 0.65, size: 50, col: color('#F44F0A'), type:'plus' };
      }

      function draw() {
        background(30);

        // Draw shapes
        drawTriangleShape(tri);
        drawCircleShape(cir);
        drawStarShape(star);
        drawPlusShape(plus);

        // Handle ghost shapes from the other player
        if (ghostShapes) drawGhost(ghostShapes);

        // If role is DJ, handle audio control and draw the DJ bar
        if (role === 'dj') {
           //  && loopSound
          // console.log("DJ role active");
          if (!loopSound || !loopSound.isPlaying()) { 
            startAudioBtn.style.display = 'inline-block';
          }

          // Draw the shared wave
          drawRadialWaveCrazy(); 
          updateAudioFromShapes();  
          drawDJBar();  
        }

        // If role is VJ, draw visual wave and the VJ bar
        if (role === 'vj') {
          drawRadialWaveCrazy();  
          drawVJBar(); 
        }
      }

      // Function to load sound for both DJ and VJ roles
      function loadDJSound() {
        // FIX this  load only after userStartAudio()

        loopSound = loadSound('assets/djlexCUT.mp3', () => {
          console.log("Sound file loaded successfully.");
          if (!reverbFX) reverbFX = new p5.Reverb();
          if (!delayFX) delayFX = new p5.Delay();
          if (!resonanceFX) resonanceFX = new p5.LowPass();

          resonanceFX.process(loopSound);
          delayFX.process(loopSound, 0, 0, 1500);
          reverbFX.process(loopSound, 2, 2);
          reverbFX.drywet(0);

          loopSound.setVolume(0);
          loopSound.loop(); 
          startAudioBtn.style.display = 'none';
        }, (error) => {
          console.error("Error loading sound file:", error); 
          startAudioBtn.disabled = true;
        });
      }

      startAudioBtn.onclick = function () {
        userStartAudio().then(() => {
          if (loopSound && loopSound.isLoaded()) {
            loopSound.loop();
            startAudioBtn.style.display = 'none';
          }
        }).catch((e) => {
          console.error('Audio unlock failed:', e);
        });
      };

      function drawDJBar() {
        noStroke();
        fill("#0A5598");
        rect(0, height - 120, width, 120);
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(30);
        text('Drag shapes to control your MUSIC', width / 2, height - 50);
        textSize(15);
        fill(220);
        text('Triangle/Volume   Circle/Reverb   Star/Delay   Plus/Resonance', width / 2, height - 90);
      }

      function drawVJBar() {
        noStroke();
        fill("#BA0113");
        rect(0, height - 120, width, 120);
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(30);
        text('Drag shapes to control your WAVE', width / 2, height - 50);
        textSize(15);
        fill(220);
        text('Triangle/Power   Circle/Softness   Star/Speed   Plus/Chaos', width / 2, height - 90);
      }

      // Ghost shapes drawing (from other player)
      function drawGhost(shapes) {
        shapes.forEach(shape => {
          if (shape.type === 'triangle') drawTriangleShape(shape);
          else if (shape.type === 'circle') drawCircleShape(shape);
          else if (shape.type === 'star') drawStarShape(shape);
          else if (shape.type === 'plus') drawPlusShape(shape);
        });
      }

      // Update sound parameters for DJ based on shape positions
      function updateAudioFromShapes() {
        if (!loopSound || !loopSound.isLoaded() || !reverbFX || !delayFX || !resonanceFX) return;

        let volume = map(tri.y, height - margin, margin, 0, 4, true);
        let reverbWet = map(cir.y, margin, height - margin, 0, 1, true);
        let delayFb = map(star.x, margin, width - margin, 0, 1, true);
        let resonance = map(plus.x, margin, width - margin, 0.1, 20, true);

        loopSound.setVolume(volume);
        reverbFX.drywet(reverbWet);
        delayFX.feedback(delayFb);
        resonanceFX.res(resonance);
      }

      // Update visual effect parameters for VJ based on shape positions
      function updateVisualFromShapes(shapes) {
        let p = map(shapes[0].y, height - margin, margin, 0, 1, true); 
        let s = map(shapes[1].y, margin, height - margin, 0, 1, true); 
        let sp = map(shapes[2].x, margin, width - margin, 0, 1, true); 
        let ch = map(shapes[3].x, margin, width - margin, 0, 1, true); 

        drawRadialWaveCrazy(p, s, sp, ch);
      }

      // Visual effect drawing for shared wave
      function drawRadialWaveCrazy(p, s, sp, ch) {
        let t = frameCount * (0.005 + sp * 0.25);
        let spacing = map(s, 0, 1, 26, 8);
        let dotSize = map(s, 0, 1, 2, 7);
        let rayCount = int(map(sp, 0, 1, 8, 80));
        let sharpness = map(p, 0, 1, 1.5, 12);
        let baseAmp = map(p, 0, 1, 0.8, 3.5);
        let radiusMax = sqrt(width * width + height * height) * map(p, 0, 1, 0.4, 0.8);
        let noiseScale = map(ch, 0, 1, 0.0, 0.02);
        let noiseStrength = map(ch, 0, 1, 0.0, 4.0);
        let bendAmount = map(ch, 0, 1, 0.0, 1.0);

        colorMode(HSB, 360, 100, 100, 100);
        noStroke();

        for (let y = 0; y < height - 120; y += spacing) {
          for (let x = 0; x < width; x += spacing) {
            let dx = x - width / 2;
            let dy = y - height / 2;
            let r = sqrt(dx * dx + dy * dy);
            let rNorm = r / radiusMax;
            let angle = atan2(dy, dx);
            if (bendAmount > 0) angle += bendAmount * sin(angle * 4.0 + t * 2.0);
            let angNorm = (angle + PI) / TWO_PI;
            let rayPhase = angle * rayCount + t * (1.0 + sp * 2.0);
            let base = max(0, cos(rayPhase) * baseAmp);
            let beam = pow(base, sharpness);
            let harmonic = max(0, cos(rayPhase * 3.0 - t * 3.0));
            beam += 0.35 * pow(harmonic, 4);

            if (noiseScale > 0.0) {
              let n = noise(x * noiseScale, y * noiseScale, t * 0.7);
              beam *= 1.0 + (n - 0.5) * noiseStrength;
            }

            let falloffExp = map(p, 0, 1, 1.4, 0.6);
            let radial = max(0, 1.0 - pow(rNorm, falloffExp));
            let intensity = constrain(beam * radial, 0, 1);
            if (intensity < 0.03) continue;

            let hue = (angNorm * 360 * 3.0 + t * 60.0) % 360;
            let sat = 70 + 30 * intensity;
            let bri = 20 + 80 * pow(intensity, 0.9);
            let alpha = (50 + 70 * intensity) * (0.2 + 0.8 * p);

            fill(hue, sat, bri, alpha);
            ellipse(x, y, dotSize, dotSize);
          }
        }

        colorMode(RGB, 255);
      }

      function mousePressed() {
        if (hitCircle(cir, mouseX, mouseY)) {
          draggedShape = cir;
        } else if (hitTriangle(tri, mouseX, mouseY)) {
          draggedShape = tri;
        } else if (hitStar(star, mouseX, mouseY)) {
          draggedShape = star;
        } else if (hitPlus(plus, mouseX, mouseY)) {
          draggedShape = plus;
        } else {
          draggedShape = null;
        }
      }

      function mouseDragged() {
        if (!draggedShape) return;

        draggedShape.x = constrain(mouseX, margin, width - margin);
        draggedShape.y = constrain(mouseY, margin, height - 180);
        
        // Send the shape position to the other player via WebSocket
        ws.send(JSON.stringify({
          type: 'state',
          role: role,
          shapes: [tri, cir, star, plus]
        }));
      }

      function mouseReleased() {
        draggedShape = null;
      }

      // Hit test for shapes
      function hitCircle(s, px, py) {
        return dist(px, py, s.x, s.y) <= s.r;
      }

      function hitTriangle(s, px, py) {
        let r = s.size * 1.1;
        return dist(px, py, s.x, s.y) <= r;
      }

      function hitStar(s, px, py) {
        let r = s.rOuter * 1.1;
        return dist(px, py, s.x, s.y) <= r;
      }

      function hitPlus(s, px, py) {
        const half = s.size;
        return px >= s.x - half && px <= s.x + half &&
               py >= s.y - half && py <= s.y + half;
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight);
        [tri, cir, star, plus].forEach(s => {
          s.x = constrain(s.x, margin, width - margin);
          s.y = constrain(s.y, margin, height - margin);
        });
      }
    </script>
  </body>
</html>
